

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Signals &mdash; django-chinese-docs 1.10 文档</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="索引"
              href="../genindex.html"/>
        <link rel="search" title="搜索" href="../search.html"/>
    <link rel="top" title="django-chinese-docs 1.10 文档" href="../index.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> django-chinese-docs
          

          
          </a>

          
            
            
              <div class="version">
                1.10
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../intro/index.html">入门教程</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">django-chinese-docs</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Signals</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/ref/signals.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="signals">
<h1>Signals<a class="headerlink" href="#signals" title="永久链接至标题">¶</a></h1>
<p>A list of all the signals that Django sends. All built-in signals are sent
using the <a class="reference internal" href="../topics/signals.html#django.dispatch.Signal.send" title="django.dispatch.Signal.send"><code class="xref py py-meth docutils literal"><span class="pre">send()</span></code></a> method.</p>
<div class="admonition seealso">
<p class="first admonition-title">参见</p>
<p>See the documentation on the <a class="reference internal" href="../topics/signals.html"><span class="doc">signal dispatcher</span></a> for
information regarding how to register for and receive signals.</p>
<p class="last">The <a class="reference internal" href="../topics/auth/index.html"><span class="doc">authentication framework</span></a> sends <a class="reference internal" href="contrib/auth.html#topics-auth-signals"><span class="std std-ref">signals when
a user is logged in / out</span></a>.</p>
</div>
<div class="section" id="module-django.db.models.signals">
<span id="model-signals"></span><h2>Model signals<a class="headerlink" href="#module-django.db.models.signals" title="永久链接至标题">¶</a></h2>
<p>The <a class="reference internal" href="#module-django.db.models.signals" title="django.db.models.signals: Signals sent by the model system."><code class="xref py py-mod docutils literal"><span class="pre">django.db.models.signals</span></code></a> module defines a set of signals sent by the
model system.</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p>Many of these signals are sent by various model methods like
<code class="docutils literal"><span class="pre">__init__()</span></code> or <a class="reference internal" href="models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code class="xref py py-meth docutils literal"><span class="pre">save()</span></code></a> that you can
override in your own code.</p>
<p>If you override these methods on your model, you must call the parent class’
methods for this signals to be sent.</p>
<p class="last">Note also that Django stores signal handlers as weak references by default,
so if your handler is a local function, it may be garbage collected.  To
prevent this, pass <code class="docutils literal"><span class="pre">weak=False</span></code> when you call the signal’s <a class="reference internal" href="../topics/signals.html#django.dispatch.Signal.connect" title="django.dispatch.Signal.connect"><code class="xref py py-meth docutils literal"><span class="pre">connect()</span></code></a>.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">Model signals <code class="docutils literal"><span class="pre">sender</span></code> model can be lazily referenced when connecting a
receiver by specifying its full application label. For example, an
<code class="docutils literal"><span class="pre">Answer</span></code> model defined in the <code class="docutils literal"><span class="pre">polls</span></code> application could be referenced
as <code class="docutils literal"><span class="pre">'polls.Answer'</span></code>. This sort of reference can be quite handy when
dealing with circular import dependencies and swappable models.</p>
</div>
<div class="section" id="pre-init">
<h3><code class="docutils literal"><span class="pre">pre_init</span></code><a class="headerlink" href="#pre-init" title="永久链接至标题">¶</a></h3>
<dl class="attribute">
<dt id="django.db.models.signals.pre_init">
<code class="descclassname">django.db.models.signals.</code><code class="descname">pre_init</code><a class="headerlink" href="#django.db.models.signals.pre_init" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<p>Whenever you instantiate a Django model, this signal is sent at the beginning
of the model’s <code class="docutils literal"><span class="pre">__init__()</span></code> method.</p>
<p>Arguments sent with this signal:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">sender</span></code></dt>
<dd>The model class that just had an instance created.</dd>
<dt><code class="docutils literal"><span class="pre">args</span></code></dt>
<dd>A list of positional arguments passed to <code class="docutils literal"><span class="pre">__init__()</span></code>:</dd>
<dt><code class="docutils literal"><span class="pre">kwargs</span></code></dt>
<dd>A dictionary of keyword arguments passed to <code class="docutils literal"><span class="pre">__init__()</span></code>:</dd>
</dl>
<p>For example, the <a class="reference internal" href="../intro/tutorial01.html"><span class="doc">tutorial</span></a> has this line:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">p</span> <span class="o">=</span> <span class="n">Poll</span><span class="p">(</span><span class="n">question</span><span class="o">=</span><span class="s">&quot;What&#39;s up?&quot;</span><span class="p">,</span> <span class="n">pub_date</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">())</span>
</pre></div>
</div>
<p>The arguments sent to a <a class="reference internal" href="#django.db.models.signals.pre_init" title="django.db.models.signals.pre_init"><code class="xref py py-data docutils literal"><span class="pre">pre_init</span></code></a> handler would be:</p>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="86%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Argument</th>
<th class="head">Value</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">sender</span></code></td>
<td><code class="docutils literal"><span class="pre">Poll</span></code> (the class itself)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">args</span></code></td>
<td><code class="docutils literal"><span class="pre">[]</span></code> (an empty list because there were no positional
arguments passed to <code class="docutils literal"><span class="pre">__init__()</span></code>.)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">kwargs</span></code></td>
<td><code class="docutils literal"><span class="pre">{'question':</span> <span class="pre">&quot;What's</span> <span class="pre">up?&quot;,</span> <span class="pre">'pub_date':</span> <span class="pre">datetime.now()}</span></code></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="post-init">
<h3><code class="docutils literal"><span class="pre">post_init</span></code><a class="headerlink" href="#post-init" title="永久链接至标题">¶</a></h3>
<dl class="data">
<dt id="django.db.models.signals.post_init">
<code class="descclassname">django.db.models.signals.</code><code class="descname">post_init</code><a class="headerlink" href="#django.db.models.signals.post_init" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<p>Like pre_init, but this one is sent when the <code class="docutils literal"><span class="pre">__init__()</span></code> method finishes.</p>
<p>Arguments sent with this signal:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">sender</span></code></dt>
<dd>As above: the model class that just had an instance created.</dd>
<dt><code class="docutils literal"><span class="pre">instance</span></code></dt>
<dd>The actual instance of the model that’s just been created.</dd>
</dl>
</div>
<div class="section" id="pre-save">
<h3><code class="docutils literal"><span class="pre">pre_save</span></code><a class="headerlink" href="#pre-save" title="永久链接至标题">¶</a></h3>
<dl class="data">
<dt id="django.db.models.signals.pre_save">
<code class="descclassname">django.db.models.signals.</code><code class="descname">pre_save</code><a class="headerlink" href="#django.db.models.signals.pre_save" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<p>This is sent at the beginning of a model’s <a class="reference internal" href="models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code class="xref py py-meth docutils literal"><span class="pre">save()</span></code></a>
method.</p>
<p>Arguments sent with this signal:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">sender</span></code></dt>
<dd>The model class.</dd>
<dt><code class="docutils literal"><span class="pre">instance</span></code></dt>
<dd>The actual instance being saved.</dd>
<dt><code class="docutils literal"><span class="pre">raw</span></code></dt>
<dd>A boolean; <code class="docutils literal"><span class="pre">True</span></code> if the model is saved exactly as presented
(i.e. when loading a fixture). One should not query/modify other
records in the database as the database might not be in a
consistent state yet.</dd>
<dt><code class="docutils literal"><span class="pre">using</span></code></dt>
<dd>The database alias being used.</dd>
<dt><code class="docutils literal"><span class="pre">update_fields</span></code></dt>
<dd>The set of fields to update as passed to <a class="reference internal" href="models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code class="xref py py-meth docutils literal"><span class="pre">Model.save()</span></code></a>, or <code class="docutils literal"><span class="pre">None</span></code>
if <code class="docutils literal"><span class="pre">update_fields</span></code> wasn’t passed to <code class="docutils literal"><span class="pre">save()</span></code>.</dd>
</dl>
</div>
<div class="section" id="post-save">
<h3><code class="docutils literal"><span class="pre">post_save</span></code><a class="headerlink" href="#post-save" title="永久链接至标题">¶</a></h3>
<dl class="data">
<dt id="django.db.models.signals.post_save">
<code class="descclassname">django.db.models.signals.</code><code class="descname">post_save</code><a class="headerlink" href="#django.db.models.signals.post_save" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<p>Like <a class="reference internal" href="#django.db.models.signals.pre_save" title="django.db.models.signals.pre_save"><code class="xref py py-data docutils literal"><span class="pre">pre_save</span></code></a>, but sent at the end of the
<a class="reference internal" href="models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code class="xref py py-meth docutils literal"><span class="pre">save()</span></code></a> method.</p>
<p>Arguments sent with this signal:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">sender</span></code></dt>
<dd>The model class.</dd>
<dt><code class="docutils literal"><span class="pre">instance</span></code></dt>
<dd>The actual instance being saved.</dd>
<dt><code class="docutils literal"><span class="pre">created</span></code></dt>
<dd>A boolean; <code class="docutils literal"><span class="pre">True</span></code> if a new record was created.</dd>
<dt><code class="docutils literal"><span class="pre">raw</span></code></dt>
<dd>A boolean; <code class="docutils literal"><span class="pre">True</span></code> if the model is saved exactly as presented
(i.e. when loading a fixture). One should not query/modify other
records in the database as the database might not be in a
consistent state yet.</dd>
<dt><code class="docutils literal"><span class="pre">using</span></code></dt>
<dd>The database alias being used.</dd>
<dt><code class="docutils literal"><span class="pre">update_fields</span></code></dt>
<dd>The set of fields to update as passed to <a class="reference internal" href="models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code class="xref py py-meth docutils literal"><span class="pre">Model.save()</span></code></a>, or <code class="docutils literal"><span class="pre">None</span></code>
if <code class="docutils literal"><span class="pre">update_fields</span></code> wasn’t passed to <code class="docutils literal"><span class="pre">save()</span></code>.</dd>
</dl>
</div>
<div class="section" id="pre-delete">
<h3><code class="docutils literal"><span class="pre">pre_delete</span></code><a class="headerlink" href="#pre-delete" title="永久链接至标题">¶</a></h3>
<dl class="data">
<dt id="django.db.models.signals.pre_delete">
<code class="descclassname">django.db.models.signals.</code><code class="descname">pre_delete</code><a class="headerlink" href="#django.db.models.signals.pre_delete" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<p>Sent at the beginning of a model’s <a class="reference internal" href="models/instances.html#django.db.models.Model.delete" title="django.db.models.Model.delete"><code class="xref py py-meth docutils literal"><span class="pre">delete()</span></code></a>
method and a queryset’s <a class="reference internal" href="models/querysets.html#django.db.models.query.QuerySet.delete" title="django.db.models.query.QuerySet.delete"><code class="xref py py-meth docutils literal"><span class="pre">delete()</span></code></a> method.</p>
<p>Arguments sent with this signal:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">sender</span></code></dt>
<dd>The model class.</dd>
<dt><code class="docutils literal"><span class="pre">instance</span></code></dt>
<dd>The actual instance being deleted.</dd>
<dt><code class="docutils literal"><span class="pre">using</span></code></dt>
<dd>The database alias being used.</dd>
</dl>
</div>
<div class="section" id="post-delete">
<h3><code class="docutils literal"><span class="pre">post_delete</span></code><a class="headerlink" href="#post-delete" title="永久链接至标题">¶</a></h3>
<dl class="data">
<dt id="django.db.models.signals.post_delete">
<code class="descclassname">django.db.models.signals.</code><code class="descname">post_delete</code><a class="headerlink" href="#django.db.models.signals.post_delete" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<p>Like <a class="reference internal" href="#django.db.models.signals.pre_delete" title="django.db.models.signals.pre_delete"><code class="xref py py-data docutils literal"><span class="pre">pre_delete</span></code></a>, but sent at the end of a model’s
<a class="reference internal" href="models/instances.html#django.db.models.Model.delete" title="django.db.models.Model.delete"><code class="xref py py-meth docutils literal"><span class="pre">delete()</span></code></a> method and a queryset’s
<a class="reference internal" href="models/querysets.html#django.db.models.query.QuerySet.delete" title="django.db.models.query.QuerySet.delete"><code class="xref py py-meth docutils literal"><span class="pre">delete()</span></code></a> method.</p>
<p>Arguments sent with this signal:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">sender</span></code></dt>
<dd>The model class.</dd>
<dt><code class="docutils literal"><span class="pre">instance</span></code></dt>
<dd><p class="first">The actual instance being deleted.</p>
<p class="last">Note that the object will no longer be in the database, so be very
careful what you do with this instance.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">using</span></code></dt>
<dd>The database alias being used.</dd>
</dl>
</div>
<div class="section" id="m2m-changed">
<h3><code class="docutils literal"><span class="pre">m2m_changed</span></code><a class="headerlink" href="#m2m-changed" title="永久链接至标题">¶</a></h3>
<dl class="data">
<dt id="django.db.models.signals.m2m_changed">
<code class="descclassname">django.db.models.signals.</code><code class="descname">m2m_changed</code><a class="headerlink" href="#django.db.models.signals.m2m_changed" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<p>Sent when a <a class="reference internal" href="models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code class="xref py py-class docutils literal"><span class="pre">ManyToManyField</span></code></a> is changed on a model
instance. Strictly speaking, this is not a model signal since it is sent by the
<a class="reference internal" href="models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code class="xref py py-class docutils literal"><span class="pre">ManyToManyField</span></code></a>, but since it complements the
<a class="reference internal" href="#django.db.models.signals.pre_save" title="django.db.models.signals.pre_save"><code class="xref py py-data docutils literal"><span class="pre">pre_save</span></code></a>/<a class="reference internal" href="#django.db.models.signals.post_save" title="django.db.models.signals.post_save"><code class="xref py py-data docutils literal"><span class="pre">post_save</span></code></a> and <a class="reference internal" href="#django.db.models.signals.pre_delete" title="django.db.models.signals.pre_delete"><code class="xref py py-data docutils literal"><span class="pre">pre_delete</span></code></a>/<a class="reference internal" href="#django.db.models.signals.post_delete" title="django.db.models.signals.post_delete"><code class="xref py py-data docutils literal"><span class="pre">post_delete</span></code></a>
when it comes to tracking changes to models, it is included here.</p>
<p>Arguments sent with this signal:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">sender</span></code></dt>
<dd>The intermediate model class describing the
<a class="reference internal" href="models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code class="xref py py-class docutils literal"><span class="pre">ManyToManyField</span></code></a>. This class is automatically
created when a many-to-many field is defined; you can access it using the
<code class="docutils literal"><span class="pre">through</span></code> attribute on the many-to-many field.</dd>
<dt><code class="docutils literal"><span class="pre">instance</span></code></dt>
<dd>The instance whose many-to-many relation is updated. This can be an
instance of the <code class="docutils literal"><span class="pre">sender</span></code>, or of the class the
<a class="reference internal" href="models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code class="xref py py-class docutils literal"><span class="pre">ManyToManyField</span></code></a> is related to.</dd>
<dt><code class="docutils literal"><span class="pre">action</span></code></dt>
<dd><p class="first">A string indicating the type of update that is done on the relation.
This can be one of the following:</p>
<dl class="last docutils">
<dt><code class="docutils literal"><span class="pre">&quot;pre_add&quot;</span></code></dt>
<dd>Sent <em>before</em> one or more objects are added to the relation.</dd>
<dt><code class="docutils literal"><span class="pre">&quot;post_add&quot;</span></code></dt>
<dd>Sent <em>after</em> one or more objects are added to the relation.</dd>
<dt><code class="docutils literal"><span class="pre">&quot;pre_remove&quot;</span></code></dt>
<dd>Sent <em>before</em> one or more objects are removed from the relation.</dd>
<dt><code class="docutils literal"><span class="pre">&quot;post_remove&quot;</span></code></dt>
<dd>Sent <em>after</em> one or more objects are removed from the relation.</dd>
<dt><code class="docutils literal"><span class="pre">&quot;pre_clear&quot;</span></code></dt>
<dd>Sent <em>before</em> the relation is cleared.</dd>
<dt><code class="docutils literal"><span class="pre">&quot;post_clear&quot;</span></code></dt>
<dd>Sent <em>after</em> the relation is cleared.</dd>
</dl>
</dd>
<dt><code class="docutils literal"><span class="pre">reverse</span></code></dt>
<dd>Indicates which side of the relation is updated (i.e., if it is the
forward or reverse relation that is being modified).</dd>
<dt><code class="docutils literal"><span class="pre">model</span></code></dt>
<dd>The class of the objects that are added to, removed from or cleared
from the relation.</dd>
<dt><code class="docutils literal"><span class="pre">pk_set</span></code></dt>
<dd><p class="first">For the <code class="docutils literal"><span class="pre">pre_add</span></code>, <code class="docutils literal"><span class="pre">post_add</span></code>, <code class="docutils literal"><span class="pre">pre_remove</span></code> and <code class="docutils literal"><span class="pre">post_remove</span></code>
actions, this is a set of primary key values that have been added to
or removed from the relation.</p>
<p class="last">For the <code class="docutils literal"><span class="pre">pre_clear</span></code> and <code class="docutils literal"><span class="pre">post_clear</span></code> actions, this is <code class="docutils literal"><span class="pre">None</span></code>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">using</span></code></dt>
<dd>The database alias being used.</dd>
</dl>
<p>For example, if a <code class="docutils literal"><span class="pre">Pizza</span></code> can have multiple <code class="docutils literal"><span class="pre">Topping</span></code> objects, modeled
like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Topping</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="c"># ...</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">Pizza</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="c"># ...</span>
    <span class="n">toppings</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ManyToManyField</span><span class="p">(</span><span class="n">Topping</span><span class="p">)</span>
</pre></div>
</div>
<p>If we connected a handler like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">django.db.models.signals</span> <span class="k">import</span> <span class="n">m2m_changed</span>

<span class="k">def</span> <span class="nf">toppings_changed</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="c"># Do something</span>
    <span class="k">pass</span>

<span class="n">m2m_changed</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">toppings_changed</span><span class="p">,</span> <span class="n">sender</span><span class="o">=</span><span class="n">Pizza</span><span class="o">.</span><span class="n">toppings</span><span class="o">.</span><span class="n">through</span><span class="p">)</span>
</pre></div>
</div>
<p>and then did something like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Pizza</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">Topping</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">toppings</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>the arguments sent to a <a class="reference internal" href="#django.db.models.signals.m2m_changed" title="django.db.models.signals.m2m_changed"><code class="xref py py-data docutils literal"><span class="pre">m2m_changed</span></code></a> handler (<code class="docutils literal"><span class="pre">toppings_changed</span></code> in
the example above) would be:</p>
<table border="1" class="docutils">
<colgroup>
<col width="18%" />
<col width="82%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Argument</th>
<th class="head">Value</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">sender</span></code></td>
<td><code class="docutils literal"><span class="pre">Pizza.toppings.through</span></code> (the intermediate m2m class)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">instance</span></code></td>
<td><code class="docutils literal"><span class="pre">p</span></code> (the <code class="docutils literal"><span class="pre">Pizza</span></code> instance being modified)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">action</span></code></td>
<td><code class="docutils literal"><span class="pre">&quot;pre_add&quot;</span></code> (followed by a separate signal with <code class="docutils literal"><span class="pre">&quot;post_add&quot;</span></code>)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">reverse</span></code></td>
<td><code class="docutils literal"><span class="pre">False</span></code> (<code class="docutils literal"><span class="pre">Pizza</span></code> contains the
<a class="reference internal" href="models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code class="xref py py-class docutils literal"><span class="pre">ManyToManyField</span></code></a>, so this call
modifies the forward relation)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">model</span></code></td>
<td><code class="docutils literal"><span class="pre">Topping</span></code> (the class of the objects added to the
<code class="docutils literal"><span class="pre">Pizza</span></code>)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">pk_set</span></code></td>
<td><code class="docutils literal"><span class="pre">{t.id}</span></code> (since only <code class="docutils literal"><span class="pre">Topping</span> <span class="pre">t</span></code> was added to the relation)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">using</span></code></td>
<td><code class="docutils literal"><span class="pre">&quot;default&quot;</span></code> (since the default router sends writes here)</td>
</tr>
</tbody>
</table>
<p>And if we would then do something like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">pizza_set</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
</pre></div>
</div>
<p>the arguments sent to a <a class="reference internal" href="#django.db.models.signals.m2m_changed" title="django.db.models.signals.m2m_changed"><code class="xref py py-data docutils literal"><span class="pre">m2m_changed</span></code></a> handler would be:</p>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="84%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Argument</th>
<th class="head">Value</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">sender</span></code></td>
<td><code class="docutils literal"><span class="pre">Pizza.toppings.through</span></code> (the intermediate m2m class)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">instance</span></code></td>
<td><code class="docutils literal"><span class="pre">t</span></code> (the <code class="docutils literal"><span class="pre">Topping</span></code> instance being modified)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">action</span></code></td>
<td><code class="docutils literal"><span class="pre">&quot;pre_remove&quot;</span></code> (followed by a separate signal with <code class="docutils literal"><span class="pre">&quot;post_remove&quot;</span></code>)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">reverse</span></code></td>
<td><code class="docutils literal"><span class="pre">True</span></code> (<code class="docutils literal"><span class="pre">Pizza</span></code> contains the
<a class="reference internal" href="models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code class="xref py py-class docutils literal"><span class="pre">ManyToManyField</span></code></a>, so this call
modifies the reverse relation)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">model</span></code></td>
<td><code class="docutils literal"><span class="pre">Pizza</span></code> (the class of the objects removed from the
<code class="docutils literal"><span class="pre">Topping</span></code>)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">pk_set</span></code></td>
<td><code class="docutils literal"><span class="pre">{p.id}</span></code> (since only <code class="docutils literal"><span class="pre">Pizza</span> <span class="pre">p</span></code> was removed from the
relation)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">using</span></code></td>
<td><code class="docutils literal"><span class="pre">&quot;default&quot;</span></code> (since the default router sends writes here)</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="class-prepared">
<h3><code class="docutils literal"><span class="pre">class_prepared</span></code><a class="headerlink" href="#class-prepared" title="永久链接至标题">¶</a></h3>
<dl class="data">
<dt id="django.db.models.signals.class_prepared">
<code class="descclassname">django.db.models.signals.</code><code class="descname">class_prepared</code><a class="headerlink" href="#django.db.models.signals.class_prepared" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<p>Sent whenever a model class has been “prepared” – that is, once model has
been defined and registered with Django’s model system. Django uses this
signal internally; it’s not generally used in third-party applications.</p>
<p>Since this signal is sent during the app registry population process, and
<a class="reference internal" href="applications.html#django.apps.AppConfig.ready" title="django.apps.AppConfig.ready"><code class="xref py py-meth docutils literal"><span class="pre">AppConfig.ready()</span></code></a> runs after the app
registry is fully populated, receivers cannot be connected in that method.
One possibility is to connect them <code class="docutils literal"><span class="pre">AppConfig.__init__()</span></code> instead, taking
care not to import models or trigger calls to the app registry.</p>
<p>Arguments that are sent with this signal:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">sender</span></code></dt>
<dd>The model class which was just prepared.</dd>
</dl>
</div>
</div>
<div class="section" id="management-signals">
<h2>Management signals<a class="headerlink" href="#management-signals" title="永久链接至标题">¶</a></h2>
<p>Signals sent by <a class="reference internal" href="django-admin.html"><span class="doc">django-admin</span></a>.</p>
<div class="section" id="pre-migrate">
<h3><code class="docutils literal"><span class="pre">pre_migrate</span></code><a class="headerlink" href="#pre-migrate" title="永久链接至标题">¶</a></h3>
<dl class="data">
<dt id="django.db.models.signals.pre_migrate">
<code class="descclassname">django.db.models.signals.</code><code class="descname">pre_migrate</code><a class="headerlink" href="#django.db.models.signals.pre_migrate" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<p>Sent by the <a class="reference internal" href="django-admin.html#django-admin-migrate"><code class="xref std std-djadmin docutils literal"><span class="pre">migrate</span></code></a> command before it starts to install an
application. It’s not emitted for applications that lack a <code class="docutils literal"><span class="pre">models</span></code> module.</p>
<p>Arguments sent with this signal:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">sender</span></code></dt>
<dd>An <a class="reference internal" href="applications.html#django.apps.AppConfig" title="django.apps.AppConfig"><code class="xref py py-class docutils literal"><span class="pre">AppConfig</span></code></a> instance for the application about to
be migrated/synced.</dd>
<dt><code class="docutils literal"><span class="pre">app_config</span></code></dt>
<dd>Same as <code class="docutils literal"><span class="pre">sender</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">verbosity</span></code></dt>
<dd><p class="first">Indicates how much information manage.py is printing on screen. See
the <a class="reference internal" href="django-admin.html#cmdoption-verbosity"><code class="xref std std-option docutils literal"><span class="pre">--verbosity</span></code></a> flag for details.</p>
<p class="last">Functions which listen for <a class="reference internal" href="#django.db.models.signals.pre_migrate" title="django.db.models.signals.pre_migrate"><code class="xref py py-data docutils literal"><span class="pre">pre_migrate</span></code></a> should adjust what they
output to the screen based on the value of this argument.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">interactive</span></code></dt>
<dd><p class="first">If <code class="docutils literal"><span class="pre">interactive</span></code> is <code class="docutils literal"><span class="pre">True</span></code>, it’s safe to prompt the user to input
things on the command line. If <code class="docutils literal"><span class="pre">interactive</span></code> is <code class="docutils literal"><span class="pre">False</span></code>, functions
which listen for this signal should not try to prompt for anything.</p>
<p class="last">For example, the <a class="reference internal" href="../topics/auth/index.html#module-django.contrib.auth" title="django.contrib.auth: Django's authentication framework."><code class="xref py py-mod docutils literal"><span class="pre">django.contrib.auth</span></code></a> app only prompts to create a
superuser when <code class="docutils literal"><span class="pre">interactive</span></code> is <code class="docutils literal"><span class="pre">True</span></code>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">using</span></code></dt>
<dd>The alias of database on which a command will operate.</dd>
<dt><code class="docutils literal"><span class="pre">plan</span></code></dt>
<dd><div class="first versionadded">
</div>
<p class="last">The migration plan that is going to be used for the migration run. While
the plan is not public API, this allows for the rare cases when it is
necessary to know the plan. A plan is a list of two-tuples with the first
item being the instance of a migration class and the second item showing
if the migration was rolled back (<code class="docutils literal"><span class="pre">True</span></code>) or applied (<code class="docutils literal"><span class="pre">False</span></code>).</p>
</dd>
<dt><code class="docutils literal"><span class="pre">apps</span></code></dt>
<dd><div class="first versionadded">
</div>
<p class="last">An instance of <a class="reference internal" href="applications.html#module-django.apps" title="django.apps"><code class="xref py py-data docutils literal"><span class="pre">Apps</span></code></a> containing the state of the
project before the migration run. It should be used instead of the global
<a class="reference internal" href="applications.html#django.apps.apps" title="django.apps.apps"><code class="xref py py-attr docutils literal"><span class="pre">apps</span></code></a> registry to retrieve the models you
want to perform operations on.</p>
</dd>
</dl>
</div>
<div class="section" id="post-migrate">
<h3><code class="docutils literal"><span class="pre">post_migrate</span></code><a class="headerlink" href="#post-migrate" title="永久链接至标题">¶</a></h3>
<dl class="data">
<dt id="django.db.models.signals.post_migrate">
<code class="descclassname">django.db.models.signals.</code><code class="descname">post_migrate</code><a class="headerlink" href="#django.db.models.signals.post_migrate" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<p>Sent at the end of the <a class="reference internal" href="django-admin.html#django-admin-migrate"><code class="xref std std-djadmin docutils literal"><span class="pre">migrate</span></code></a> (even if no migrations are run) and
<a class="reference internal" href="django-admin.html#django-admin-flush"><code class="xref std std-djadmin docutils literal"><span class="pre">flush</span></code></a> commands. It’s not emitted for applications that lack a
<code class="docutils literal"><span class="pre">models</span></code> module.</p>
<p>Handlers of this signal must not perform database schema alterations as doing
so may cause the <a class="reference internal" href="django-admin.html#django-admin-flush"><code class="xref std std-djadmin docutils literal"><span class="pre">flush</span></code></a> command to fail if it runs during the
<a class="reference internal" href="django-admin.html#django-admin-migrate"><code class="xref std std-djadmin docutils literal"><span class="pre">migrate</span></code></a> command.</p>
<p>Arguments sent with this signal:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">sender</span></code></dt>
<dd>An <a class="reference internal" href="applications.html#django.apps.AppConfig" title="django.apps.AppConfig"><code class="xref py py-class docutils literal"><span class="pre">AppConfig</span></code></a> instance for the application that was
just installed.</dd>
<dt><code class="docutils literal"><span class="pre">app_config</span></code></dt>
<dd>Same as <code class="docutils literal"><span class="pre">sender</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">verbosity</span></code></dt>
<dd><p class="first">Indicates how much information manage.py is printing on screen. See
the <a class="reference internal" href="django-admin.html#cmdoption-verbosity"><code class="xref std std-option docutils literal"><span class="pre">--verbosity</span></code></a> flag for details.</p>
<p class="last">Functions which listen for <a class="reference internal" href="#django.db.models.signals.post_migrate" title="django.db.models.signals.post_migrate"><code class="xref py py-data docutils literal"><span class="pre">post_migrate</span></code></a> should adjust what they
output to the screen based on the value of this argument.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">interactive</span></code></dt>
<dd><p class="first">If <code class="docutils literal"><span class="pre">interactive</span></code> is <code class="docutils literal"><span class="pre">True</span></code>, it’s safe to prompt the user to input
things on the command line. If <code class="docutils literal"><span class="pre">interactive</span></code> is <code class="docutils literal"><span class="pre">False</span></code>, functions
which listen for this signal should not try to prompt for anything.</p>
<p class="last">For example, the <a class="reference internal" href="../topics/auth/index.html#module-django.contrib.auth" title="django.contrib.auth: Django's authentication framework."><code class="xref py py-mod docutils literal"><span class="pre">django.contrib.auth</span></code></a> app only prompts to create a
superuser when <code class="docutils literal"><span class="pre">interactive</span></code> is <code class="docutils literal"><span class="pre">True</span></code>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">using</span></code></dt>
<dd>The database alias used for synchronization. Defaults to the <code class="docutils literal"><span class="pre">default</span></code>
database.</dd>
<dt><code class="docutils literal"><span class="pre">plan</span></code></dt>
<dd><div class="first versionadded">
</div>
<p class="last">The migration plan that was used for the migration run. While the plan is
not public API, this allows for the rare cases when it is necessary to
know the plan. A plan is a list of two-tuples with the first item being
the instance of a migration class and the second item showing if the
migration was rolled back (<code class="docutils literal"><span class="pre">True</span></code>) or applied (<code class="docutils literal"><span class="pre">False</span></code>).</p>
</dd>
<dt><code class="docutils literal"><span class="pre">apps</span></code></dt>
<dd><div class="first versionadded">
</div>
<p class="last">An instance of <a class="reference internal" href="applications.html#django.apps.apps" title="django.apps.apps"><code class="xref py py-data docutils literal"><span class="pre">Apps</span></code></a> containing the state of the
project after the migration run. It should be used instead of the global
<a class="reference internal" href="applications.html#django.apps.apps" title="django.apps.apps"><code class="xref py py-attr docutils literal"><span class="pre">apps</span></code></a> registry to retrieve the models you
want to perform operations on.</p>
</dd>
</dl>
<p>For example, you could register a callback in an
<a class="reference internal" href="applications.html#django.apps.AppConfig" title="django.apps.AppConfig"><code class="xref py py-class docutils literal"><span class="pre">AppConfig</span></code></a> like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">django.apps</span> <span class="k">import</span> <span class="n">AppConfig</span>
<span class="kn">from</span> <span class="nn">django.db.models.signals</span> <span class="k">import</span> <span class="n">post_migrate</span>

<span class="k">def</span> <span class="nf">my_callback</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="c"># Your specific logic here</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">MyAppConfig</span><span class="p">(</span><span class="n">AppConfig</span><span class="p">):</span>
    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">ready</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">post_migrate</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">my_callback</span><span class="p">,</span> <span class="n">sender</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">If you provide an <a class="reference internal" href="applications.html#django.apps.AppConfig" title="django.apps.AppConfig"><code class="xref py py-class docutils literal"><span class="pre">AppConfig</span></code></a> instance as the sender
argument, please ensure that the signal is registered in
<a class="reference internal" href="applications.html#django.apps.AppConfig.ready" title="django.apps.AppConfig.ready"><code class="xref py py-meth docutils literal"><span class="pre">ready()</span></code></a>. <code class="docutils literal"><span class="pre">AppConfig</span></code>s are recreated for
tests that run with a modified set of <a class="reference internal" href="settings.html#std:setting-INSTALLED_APPS"><code class="xref std std-setting docutils literal"><span class="pre">INSTALLED_APPS</span></code></a> (such as
when settings are overridden) and such signals should be connected for each
new <code class="docutils literal"><span class="pre">AppConfig</span></code> instance.</p>
</div>
</div>
</div>
<div class="section" id="module-django.core.signals">
<span id="request-response-signals"></span><h2>Request/response signals<a class="headerlink" href="#module-django.core.signals" title="永久链接至标题">¶</a></h2>
<p>Signals sent by the core framework when processing a request.</p>
<div class="section" id="request-started">
<h3><code class="docutils literal"><span class="pre">request_started</span></code><a class="headerlink" href="#request-started" title="永久链接至标题">¶</a></h3>
<dl class="data">
<dt id="django.core.signals.request_started">
<code class="descclassname">django.core.signals.</code><code class="descname">request_started</code><a class="headerlink" href="#django.core.signals.request_started" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<p>Sent when Django begins processing an HTTP request.</p>
<p>Arguments sent with this signal:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">sender</span></code></dt>
<dd>The handler class – e.g. <code class="docutils literal"><span class="pre">django.core.handlers.wsgi.WsgiHandler</span></code> – that
handled the request.</dd>
<dt><code class="docutils literal"><span class="pre">environ</span></code></dt>
<dd>The <code class="docutils literal"><span class="pre">environ</span></code> dictionary provided to the request.</dd>
</dl>
</div>
<div class="section" id="request-finished">
<h3><code class="docutils literal"><span class="pre">request_finished</span></code><a class="headerlink" href="#request-finished" title="永久链接至标题">¶</a></h3>
<dl class="data">
<dt id="django.core.signals.request_finished">
<code class="descclassname">django.core.signals.</code><code class="descname">request_finished</code><a class="headerlink" href="#django.core.signals.request_finished" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<p>Sent when Django finishes delivering an HTTP response to the client.</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">Some WSGI servers and middleware do not always call <code class="docutils literal"><span class="pre">close</span></code> on the
response object after handling a request, most notably uWSGI prior to 1.2.6
and Sentry’s error reporting middleware up to 2.0.7. In those cases this
signal isn’t sent at all. This can result in idle connections to database
and memcache servers.</p>
</div>
<p>Arguments sent with this signal:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">sender</span></code></dt>
<dd>The handler class, as above.</dd>
</dl>
</div>
<div class="section" id="got-request-exception">
<h3><code class="docutils literal"><span class="pre">got_request_exception</span></code><a class="headerlink" href="#got-request-exception" title="永久链接至标题">¶</a></h3>
<dl class="data">
<dt id="django.core.signals.got_request_exception">
<code class="descclassname">django.core.signals.</code><code class="descname">got_request_exception</code><a class="headerlink" href="#django.core.signals.got_request_exception" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<p>This signal is sent whenever Django encounters an exception while processing an incoming HTTP request.</p>
<p>Arguments sent with this signal:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">sender</span></code></dt>
<dd>The handler class, as above.</dd>
<dt><code class="docutils literal"><span class="pre">request</span></code></dt>
<dd>The <a class="reference internal" href="request-response.html#django.http.HttpRequest" title="django.http.HttpRequest"><code class="xref py py-class docutils literal"><span class="pre">HttpRequest</span></code></a> object.</dd>
</dl>
</div>
</div>
<div class="section" id="module-django.test.signals">
<span id="test-signals"></span><h2>Test signals<a class="headerlink" href="#module-django.test.signals" title="永久链接至标题">¶</a></h2>
<p>Signals only sent when <a class="reference internal" href="../topics/testing/overview.html#running-tests"><span class="std std-ref">running tests</span></a>.</p>
<div class="section" id="setting-changed">
<h3><code class="docutils literal"><span class="pre">setting_changed</span></code><a class="headerlink" href="#setting-changed" title="永久链接至标题">¶</a></h3>
<dl class="data">
<dt id="django.test.signals.setting_changed">
<code class="descclassname">django.test.signals.</code><code class="descname">setting_changed</code><a class="headerlink" href="#django.test.signals.setting_changed" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<p>This signal is sent when the value of a setting is changed through the
<code class="docutils literal"><span class="pre">django.test.TestCase.settings()</span></code> context manager or the
<a class="reference internal" href="../topics/testing/tools.html#django.test.override_settings" title="django.test.override_settings"><code class="xref py py-func docutils literal"><span class="pre">django.test.override_settings()</span></code></a> decorator/context manager.</p>
<p>It’s actually sent twice: when the new value is applied (“setup”) and when the
original value is restored (“teardown”). Use the <code class="docutils literal"><span class="pre">enter</span></code> argument to
distinguish between the two.</p>
<p>You can also import this signal from <code class="docutils literal"><span class="pre">django.core.signals</span></code> to avoid importing
from <code class="docutils literal"><span class="pre">django.test</span></code> in non-test situations.</p>
<p>Arguments sent with this signal:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">sender</span></code></dt>
<dd>The settings handler.</dd>
<dt><code class="docutils literal"><span class="pre">setting</span></code></dt>
<dd>The name of the setting.</dd>
<dt><code class="docutils literal"><span class="pre">value</span></code></dt>
<dd>The value of the setting after the change. For settings that initially
don’t exist, in the “teardown” phase, <code class="docutils literal"><span class="pre">value</span></code> is <code class="docutils literal"><span class="pre">None</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">enter</span></code></dt>
<dd>A boolean; <code class="docutils literal"><span class="pre">True</span></code> if the setting is applied, <code class="docutils literal"><span class="pre">False</span></code> if restored.</dd>
</dl>
</div>
<div class="section" id="template-rendered">
<h3><code class="docutils literal"><span class="pre">template_rendered</span></code><a class="headerlink" href="#template-rendered" title="永久链接至标题">¶</a></h3>
<dl class="data">
<dt id="django.test.signals.template_rendered">
<code class="descclassname">django.test.signals.</code><code class="descname">template_rendered</code><a class="headerlink" href="#django.test.signals.template_rendered" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<p>Sent when the test system renders a template. This signal is not emitted during
normal operation of a Django server – it is only available during testing.</p>
<p>Arguments sent with this signal:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">sender</span></code></dt>
<dd>The <a class="reference internal" href="templates/api.html#django.template.Template" title="django.template.Template"><code class="xref py py-class docutils literal"><span class="pre">Template</span></code></a> object which was rendered.</dd>
<dt><code class="docutils literal"><span class="pre">template</span></code></dt>
<dd>Same as sender</dd>
<dt><code class="docutils literal"><span class="pre">context</span></code></dt>
<dd>The <a class="reference internal" href="templates/api.html#django.template.Context" title="django.template.Context"><code class="xref py py-class docutils literal"><span class="pre">Context</span></code></a> with which the template was
rendered.</dd>
</dl>
</div>
</div>
<div class="section" id="module-django.db.backends">
<span id="database-wrappers"></span><h2>Database Wrappers<a class="headerlink" href="#module-django.db.backends" title="永久链接至标题">¶</a></h2>
<p>Signals sent by the database wrapper when a database connection is
initiated.</p>
<div class="section" id="connection-created">
<h3><code class="docutils literal"><span class="pre">connection_created</span></code><a class="headerlink" href="#connection-created" title="永久链接至标题">¶</a></h3>
<dl class="data">
<dt id="django.db.backends.signals.connection_created">
<code class="descclassname">django.db.backends.signals.</code><code class="descname">connection_created</code><a class="headerlink" href="#django.db.backends.signals.connection_created" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<p>Sent when the database wrapper makes the initial connection to the
database.  This is particularly useful if you’d like to send any post
connection commands to the SQL backend.</p>
<p>Arguments sent with this signal:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">sender</span></code></dt>
<dd>The database wrapper class – i.e.
<code class="docutils literal"><span class="pre">django.db.backends.postgresql.DatabaseWrapper</span></code> or
<code class="docutils literal"><span class="pre">django.db.backends.mysql.DatabaseWrapper</span></code>, etc.</dd>
<dt><code class="docutils literal"><span class="pre">connection</span></code></dt>
<dd>The database connection that was opened. This can be used in a
multiple-database configuration to differentiate connection signals
from different databases.</dd>
</dl>
</div>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, j_hao104.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'1.10',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="../_static/translations.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>